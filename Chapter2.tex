
\begin{equation}
\begin{array} {lllrr} 
\text{min} & \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} g(x)^{f_k^i} Y_x^{f_k^i} \\\\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} T(x)^{f_k^i} Y_x^{f_k^i} & \leq &  D_{\textbf{F}} \\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} Y_x^{f_k^i} & = & 1 \\\\
& Y_x^{f_k^i} \in \lbrace 0, 1 \rbrace &&
\end{array}
\end{equation}


\begin{equation}
\begin{array} {lllrr} 
\text{min} & \displaystyle\sum_{\pi \in \Pi} \sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} g(x)^{f_k^i} Y_{(\pi, x)}^{f_k^i} \\\\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} T(x)^{f_k^i} Y_x^{f_k^i} & \leq &  D_{\textbf{F}} \\
& \displaystyle\sum_{\pi \in \Pi} \sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} Y_{(\pi, x)}^{f_k^i} & = & 1 \\\\
& Y_{(\pi, x)}^{f_k^i} \in \lbrace 0, 1 \rbrace &&
\end{array}
\end{equation}


\newpage

\section{Serverless Computing Paradigm}

In serverless computing platforms, computation is done by so-called \textit{function instances} which are completely managed by the serverless computing platform provider and act as tiny servers that can be invoked based on events forwarded by end-users \cite{PMSCP}.

Serverless computing platforms handle almost every aspect of the system administration tasks needed to deploy a workload on the cloud, providing a new simplified programming model according to which developers can focus on the business aspects of their applications only \cite{COSE}.

Moreover, the paradigm lowers the cost of deploying applications too, adopting a so-called “\textit{pay as you go}” pricing model, by charging for execution time rather than for allocated resources \cite{COSE}.


\subsection{Serverless Function}

A \textit{serverless function} represents a stateless, event-driven, self-contained unit of computation implementing a business functionality.

Although a serverless function generally represents a unit of executable code, submitted to FaaS platforms by developers using one or a combination of the programming languages supported by FaaS providers, a serverless function can be any cloud services eventually necessary to business logic, like cloud storage, message queue services, pub/sub messaging service etc.

When it represents executable code, developers can specify several configuration parameters, like timeout, memory size or CPU power \cite{COSE}.

A serverless function can be triggered through events or HTTP requests following which the FaaS provider executes it in a containerized environment, like container, virtual machine or even processes, using the specified configuration.

\subsection{Serverless Application}

A \textit{serverless application} represents a stateless and event-driven software system made up of a set of serverless functions hosted on one or more FaaS platforms and combined together by an \textit{orchestrator}, which handles events among functions and triggers them in the correct order according to the business logic defined by developers. 

\section{Orchestrator Model}

\subsection{Resource owner}

A \textit{resource owner}, henceforward denoted with $R$, represents an entity capable of \textit{creating}, \textit{modifying} and \textit{authorizing} access to several resources of our system.

\section{Serverless Choreography}

According to our framework, a \textit{serverless choreography} is a \textit{resource} used to model and implement both serverless functions and serverless applications.

Informally, a serverless choreography is derived by the control-flow graph which describes, using graph notation, all paths that might be traversed through a serverless application during its execution. Similarly, a serverless choreography describes calling relationships between serverless functions which can be combined using several types of control-flow connectors.

\subsection{Definition}

Formally, let $n \in \N \setminus \left\lbrace 0 \right\rbrace $, being $R$ the resource owner, a \textit{serverless choreography}, or simply \textit{choreography}, $\mathcal{S}_R$ owned by $R$ is a weighted directed graph defined as follows:

\begin{equation}
	\mathcal{S}_R \mathDef (\Phi,E)
\end{equation}

where:

\begin{itemize}
	\item $\Phi$ represents a finite set of vertices such that $|\Phi|=n$. 
	
	Each vertex $\phi \in \Phi$ is called \textit{abstract serverless function} which represents, generally, a computational unit; we will describe more in detail what we mean by abstract serverless function shortly;
	
	\item $E \subseteq \Phi \times \Phi $ represents a finite set of directed edges.
	
	For all $i,j \in \left[ 1, n \right]$, each directed edge from $\phi_i \in \Phi$ to $\phi_j \in \Phi$, denoted as $\left( \phi_i, \phi_j \right)$, indicates that the abstract serverless function $\phi_j$ \textit{can} be called by $\phi_i$, representing the interaction between $\phi_i$ and $\phi_j$ defined by the business logic;
	
	\item For all $i,j \in \left[ 1, n \right]$, the number $p_{ij} \in \left[ 0, 1 \right]$ is the weight assigned to the edge $\left(\phi_i, \phi_j \right)$ and represents the \textit{transition probability} from $\phi_i$ to $\phi_j$, that is the probability of invoking $\phi_j$ after finishing the execution of $\phi_i$.
	
	$P : \Phi \times \Phi \to \left[ 0, 1 \right]$ is defined as the \textit{transition probability function} according to which $P\left(\phi_i, \phi_j \right) = p_{ij}$. Clearly, when $P\left(\phi_i, \phi_j \right) = 0$, the directed edge $\left( \phi_i, \phi_j \right)$ does not exist according to business logic, therefore $\phi_i$ cannot invoke $\phi_j$;
	
\end{itemize} 

A choreography $\mathcal{S}_R$ can be uniquely identified by an ordered pair $(a, b)$, where $a$ is the name of the resource owner $R$, while $b$ is the function choreography name.

Clearly, we say that choreography models a serverless function when $|\Phi| = 1$ and $|E| = 0$; conversely, it models a serverless function application when $|\Phi| > 1$ and $|E| > 0$.

From now, a choreography $\mathcal{S}_R$ will be briefly denoted by $\mathcal{S}$ when no confusion can arise about the resource owner $R$.

\subsubsection{Notations}

Let $\mathcal{S} = (\Phi,E)$ a choreography. Let's now introduce following notations and functions:

\begin{itemize}
	\item A \textit{path} $\pi$ is defined as a finite sequence of distinct vertices and edges as follows:
	
	\begin{equation}
	\pi = \phi_1 e_1 \phi_2 e_2 \ldots e_{n-2}\phi_{n-1} e_{n-1} \phi_n
	\end{equation}
	 
	where:
	
	\begin{itemize}
		\item $\phi_i \in \Phi$, for all $i \in \left[ 1, n \right]$
		\item $e_i = \left( \phi_i, \phi_{i+1} \right) \in E$, for all $i \in \left[ 1, n-1 \right]$
	\end{itemize}
	
	\item Given a path $\pi$, we define the \textit{transition probability} of the path $\pi$ the following quantity:
	
	\begin{equation}
		TPP(\pi) = \prod_{i = 1}^{n-1} P\left(\phi_i, \phi_{i+1} \right)
	\end{equation}

	\item Let $\phi_i \in \Phi$ to $\phi_j \in \Phi$ for all $i,j \in \left[ 1, n \right]$, the set $\Pi(\phi_i, \phi_j)$ identifies all possible paths starting from vertex $\phi_i$ and ending at vertex $\phi_j$.
	
	\item The set $out(\phi_u)$ ($in(\phi_u)$) denotes all edges starting (ending) from (to) vertex $\phi_u$, while the set $succ(\phi_u)$ ($pred(\phi_u)$) includes all direct successor (predecessors) vertices of $\phi_u$. Formally:
	
	\begin{eqnarray}\label{outDef}
		out(\phi_u) & \mathDef & \left\lbrace (\phi_u, \phi) \in E, \quad \forall \phi \in \Phi  \right\rbrace \\
		in(\phi_u) & \mathDef & \left\lbrace (\phi, \phi_u) \in E, \quad \forall \phi \in \Phi  \right\rbrace \\
		succ(\phi_u) & \mathDef & \left\lbrace \phi \in \Phi \mid (\phi_u, \phi) \in out(\phi_u)  \right\rbrace \\
		pred(\phi_u) & \mathDef & \left\lbrace \phi \in \Phi \mid (\phi, \phi_u) \in in(\phi_u)  \right\rbrace 
	\end{eqnarray}
	
	\item $NI: \Phi \to \left[ 0, \infty \right)$ is a function representing the average number of invocations of an abstract serverless function $\phi \in \Phi$ during the execution of a serverless choreography $\mathcal{S}$.
	
	\item $D : \Phi \times \Phi \to \left[ 0, \infty \right)$ represents a delay function according to which $D\left(\phi_i, \phi_j \right)$ identifies the delay from $\phi_i$ to $\phi_j$ due to network delay or orchestration task;  
	
\end{itemize}

\subsubsection{Abstract Serverless Function}

Supposing that a choreography $\mathcal{S} = (\Phi,E)$ is given, an \textit{abstract serverless function} $\phi \in \Phi$, or simply \textit{abstract function}, is a \textit{resource} that represents a computational unit needed by business logic. 

According to our model, there are two types of abstract functions implementations:

\begin{itemize}
	
	\item $\phi$ is defined as \textit{serverless executable functions}, or simply \textit{executable function}, when $\phi$ contains executable code which implementing business logic.
	
	$\mathscr{F_E}$ is defined as the set containing all executable function of $\mathcal{S}$ and it is formally defined as follows:
	
	\begin{equation}
		\mathscr{F_E} \mathDef \left\lbrace \phi \in \Phi \mid \phi \text{ is a serverless executable function }\right\rbrace 
	\end{equation}
	
	However, multiple different implementations of a given executable function can be provided by developers which, although they must be semantically and logically equivalent, may eventually expose different performance or cost behavior. 
	
	Therefore, for each $\phi \in \mathscr{F_E}$, the set $\textbf{F}_{\phi}$, containing all implementations of $\phi$, generally denoted by $f_{\phi}$, such that $|\textbf{F}| \geq 1 $, must exist.

	We will explain later that the aim of our framework is to pick exactly one $f_{\phi} \in \textbf{F}_{\phi}$ whose properties allow us to meet user-specified QoS objective.
	
	We assume that every $f_{\phi} \in \textbf{F}_{\phi}$ for all $\phi \in \mathscr{F_E}$ is already deployed on one or more FaaS platform by developers.
		
	\item $\phi$ is called \textit{serverless orchestration functions}, or \textit{orchestration functions}, when $\phi$ contain orchestration code needed to decide which and how the next abstract functions must be called; in other words, orchestration code is control-flow code.
	
	$\mathscr{F_O}$ is defined as the set containing all executable function of $\mathcal{S}$ and it is formally defined as follows:
	
	\begin{equation}
		\mathscr{F_O} \mathDef \left\lbrace \phi \in \Phi \mid \phi \text{ is a serverless orchestration function }\right\rbrace 
	\end{equation}

	
\end{itemize}

Clearly, based on above definition, we can say: 

\begin{eqnarray}
\mathscr{F_E} \cap \mathscr{F_O} & = & \emptyset \\
\mathscr{F_E} \cup \mathscr{F_O} & = & \Phi \\
|\mathscr{F_E}| + |\mathscr{F_O}| &=& |\Phi| 
\end{eqnarray}

% Generally it contains the description of what the corresponding implementation does including several proprieties, like input or output data types.

According to the serverless paradigm, the execution of a serverless application starts with a particular function, which we will denote as the \textit{entry point}, while any other serverless functions, belonging to the application, will be invoked subsequently according to specified business logic. 

Clearly, the execution of a serverless application ends when ends the execution of the last function according to the business logic. That ending function will be denoted as \textit{end point}. According to our point of view, the end point is not unique.

Obliviously, in order to appropriately model a serverless application, any choreography $\mathcal{S}$ must have exactly one entry point and at least one end point. 

Given $\mathcal{S}$ a choreography, the entry point of $\mathcal{S}$ is denoted by $\phi_{entry}$ while the end point by $\phi_{end}$. Formally:

\begin{eqnarray}
	\phi_{entry} \in \Phi \text{ is the entry point of } \mathcal{S} & \Leftrightarrow & in(\phi_{entry}) = \emptyset \\
	\phi_{end} \in \Phi \text{ is the end point of } \mathcal{S} & \Leftrightarrow & out(\phi_{end}) = \emptyset
\end{eqnarray}

\subsection{Configuration}

Given a choreography $SC_R = (\Phi,E)$, the basic goal of our framework is to determine the so-called \textit{serverless choreography configuration}, or simply \textit{configuration}, of $SC_R$ that allows us to meet user-specified QoS objectives.

\subsubsection{Serverless Functions Configuration}

Let an abstract executable serverless function $\mathscr{F_E}$ and \textbf{F} the corresponding set of serverless function which implement it, we define the following vector:

\begin{equation}
	x \in \textbf{F} \times \N
\end{equation}

as the \textit{serverless functions configuration}, or simply \textit{configuration}, of $\mathscr{F_E}$. In this context, for any $f \in \textbf{F}$ and $m \in \N$, given $x =(f,m)$, $f$ represents a particular serverless function while $m$ represents the allocated memory size.

At this point, we can define some useful functions:

\begin{itemize}	
	\item $C_{\textbf{F}} : \textbf{F} \times \N \to \left[ 0, \infty \right)$ which represents a cost function for serverless functions. For any $f \in \textbf{F}$ and $n \in \N$, $C_{\textbf{F}}(f,n)$ returns the average cost paid by developers to execute $f$ using an allocated memory size equal to $n$.
	
	\item $RT_{\textbf{F}} : \textbf{F} \times \N \to \left[ 0, \infty \right)$ which represents a delay function for serverless functions. For any $f \in \textbf{F}$ and $n \in \N$, $RT_{\textbf{F}}(f,n)$ returns the average response time of function $f$ using $n$ as allocated memory size.
\end{itemize}

Any abstract serverless function is uniquely identified by an ordered string tuple $(a, b, c)$, where:
\begin{itemize}
	\item $a$ represents the name of the resource owner $R$;
	\item $b$ represents the name of the serverless choreography $SC_R$;
	\item $c$ is the name of the abstract serverless function $\phi$
\end{itemize}

\subsubsection{Serverless Choreography Configuration}

Let $n,k \in \N$, such that $k \leq n$, and $SC_R$ a serverless choreography where $|\Phi| = n$ and $|\mathscr{F_E}| = k$. 

The basic goal of our framework is to determine a so-called \textit{serverless choreography configuration} that allows us to meet user-specified QoS objectives. Formally, a serverless choreography configuration $\textbf{x}$ is a $k\times2$ matrix such that:

\begin{equation}
\textbf{X} \in \lbrace \textbf{F}_1 \times \mathbb{N} \rbrace \times \ldots \times \lbrace \textbf{F}_k \times \mathbb{N} \rbrace = \Cross_{i = 1}^k \lbrace \textbf{F}_i \times \mathbb{N} \rbrace
\end{equation}

In other words, $\textbf{x}$ is a matrix where, for $i \in \left[ 1, k \right]$, the $i$-th row contains a serverless functions configuration for the abstract executable serverless functions $F_i \in \mathscr{F_E}$. 

More precisely, for $v \in \left[ 1, k \right]$, the matrix $\textbf{X}$ is such that:

\begin{itemize}
	\item the element $(v,1)$ identifies the serverless function $f \in \textbf{F}_v$ which implements the abstract executable serverless function $F_v \in \mathscr{F_E}$;
	
	\item the element $(v,2)$ identifies the allocated memory size $m \in N$ of the serverless function identified by the element $(v,1)$.
\end{itemize}

\subsection{Metrics}

Let $\mathcal{C} = (\Phi,E)$ a choreography such that:
\begin{itemize}
	\item $\mathcal{C}$ is a DAG without any cycles and loops;
	\item Is true that the transition probabilities of all paths between the start point and
	the end point of $\mathcal{C}$ can sum up to $1$:
	
	\begin{equation}
		\sum_{\pi \in \Pi(\phi_{start}, \phi_{end})} TPP(\pi) = 1
	\end{equation}

\end{itemize}

At this point, let $\pi = \phi_1 e_1 \phi_2 e_2 \ldots e_{n-2}\phi_{n-1} e_{n-1} \phi_n$ a path. We define the response time of $\pi$ as follows:

\begin{equation}
	RT_P(\pi, \textbf{X}) = \sum_{\substack{1\le i\le n\\ \phi_i \in \mathscr{F_E}}} N(\phi_i) \cdot RT_{\textbf{F}} (X_{\phi_{i}1},X_{\phi_{i}2}) + \sum_{i = 1}^{n-1} N(\phi_i) \cdot D(\phi_i,\phi_{i+1})
\end{equation}

Let $\textbf{X}$ a configuration of the choreography $\mathcal{C}$, the response time of $\mathcal{C}$ is defined as follows:

\begin{equation}
	RT_C(\mathcal{C}, \textbf{X}) = \sum_{\pi \in \Pi(\phi_{start}, \phi_{end})} TPP(\pi) \cdot RT_{P}(\pi, \textbf{X})
\end{equation}

\subsection{Structures}

In this section, we will define several types of structures belonging to a given serverless choreography. 

Let $SC_R = (\Phi,E)$ a serverless choreography. We say that a \textit{serverless sub-choreography} $SC_R'$, or simply \textit{sub-choreography}, is a weighted directed sub-graph of $SC_R$. Formally:

\begin{equation}
	SC_R' \mathDef (\Phi',E') \qquad \text{ where } \Phi' \subseteq \Phi \wedge E' \subseteq E
\end{equation}

We denote $\phi_{start}' \in \Phi'$ and $\phi_{end}' \in \Phi'$, respectively, as the \textit{entry point} and the \textit{end point} of the sub-choreography $SC_R'$

\subsubsection{Parallel}

Supposing that a choreography $SC_R = (\Phi,E)$ is given, let us consider two vertices $\phi_i \in \Phi$ and $\phi_j \in \Phi$, for any $i,j \in \left[ 1, n \right]$ such that $i \neq j$.

We say that the sub-choreography $\mathcal{P}$, such that $\phi_{start}' = \phi_i$ and $\phi_{end}' = \phi_j$, is called \textit{parallel structure} when:

\begin{equation}
	TPP(\pi) = 1 \qquad \forall \pi \in \Pi(\phi_{start}^*, \phi_{end}^*)
\end{equation}

Let $out(\phi_{start}^*)$ the set of all edges starting from vertex as defined in equation \ref{outDef} and suppose that $|out(\phi_{start}^*)| = s \in \N \setminus \left\lbrace 0 \right\rbrace $.

Then $\Theta$ is defined as the set, such that $|\Theta| = s$, containing all the sub-choreographies $(\Phi^{**}, E^{**})$ which will be executed at the same time during the processing of the parallel structure. More precisely:

\begin{equation}
	\begin{array}{c}
	\Theta \mathDef \left\lbrace (\Phi^{**}_1, E^{**}_1), \ldots ,(\Phi^{**}_s, E^{**}_s) \right\rbrace \\\\
	\text{ where } \\\\
	\phi_{start_{i}}^{**}, \phi_{end_{i}}^{**} \in \Phi^{**}_i \\\\
	
	\phi_{start_{i}}^{**} \in succ(\phi_{start}^*) \wedge \phi_{end_{i}}^{**} \in pred (\phi_{end}^*) \quad \forall i \in \left[ 1, s \right]
	\end{array}
\end{equation} 

Simply the response time of a parallel structure is the longest response time of all
sub-choreographies $(\Phi^{**}, E^{**})$ in it, while its cost is equal to the sum of costs of execution of all sub-choreographies. Formally, being $\textbf{X}$ a configuration of the choreography $SC_R$:

\begin{equation}
	RT_{parallel}(\mathcal{P}, \textbf{X}) = max \left\lbrace RT_C(\mathcal{\theta}, \textbf{X}) \mid \theta \in \Theta \right\rbrace 
\end{equation}

\begin{equation}
	C_{parallel}(\mathcal{P}, \textbf{X}) = \sum_{\theta \in \Theta} C_C(\theta, \textbf{X})
\end{equation}

\subsubsection{Branch}

We say that A sub-choreography $\mathcal{B}$, such that $\phi_{start}' = \phi_i$ and $\phi_{end}' = \phi_j$, is called \textit{branch structure} when:

\begin{equation}
	\begin{array}{c}
	TPP(\pi) \neq 1 \qquad \forall \pi \in \Pi(\phi_{start}^*, \phi_{end}^*) \\
	\wedge \\
	\displaystyle\sum_{\pi \in \Pi(\phi_{start}^*, \phi_{end}^*)} TPP(\pi) = 1
	\end{array}
\end{equation}


\section{Optimization}


\subsection{Performance Modeling}






We define the utility function as follows:

\begin{equation}
	F(\textbf{x}) \mathDef w_{RT} \cdot \dfrac{RT_{max} - RT(\textbf{x})}{RT_{max} - RT_{min}} + w_{C} \cdot \dfrac{C_{max} - C(\textbf{x})}{C_{max} - C_{min}}
\end{equation}

where $w_{RT}, w_{C} \geq 0$, $w_{RT} + w_{C} = 1$, are weights for the different QoS attributes, while $RT_{max}$ ($RT_{min}$) and $C_{max}$ ($C_{min}$) denote, respectively, the maximum (minimum) value for the overall expected response time and cost.






Before to proceed, when the serverless workflow configuration $x$ is used,




\begin{itemize}
	\item $D(\textbf{x})$ denotes the end-to-end response time of current serverless workflow $G_s$ when the serverless workflow configuration $x$ is used. At the same time, $C(\textbf{x})$ represents the  
	\item $C(\textbf{x})$ re
\end{itemize}

gdfgdfgdfgd

\begin{itemize}
	\item $\textbf{x}(\mathscr{F})$ is used to denote the configuration $\left( f, m \right) $ of the serverless abstract function $\mathscr{F}$.
	\item $C_{func}(\textbf{x}(\mathscr{F}))$ represents the cost to pay to execute the concrete serverless function $f$ with memory size $m$.
\end{itemize}



\begin{equation}
	C_{walk}(w, \textbf{x}) = \sum_{\mathscr{F} \in w} C_{func}(\textbf{x}(\mathscr{F}))
\end{equation}


\begin{equation}
	C_{conf}(\textbf{x}) = \sum_{w \in SP_{G_s}(\mathscr{F}_{start}, \mathscr{F}_{end})} TPP(w) C(w, \textbf{x})
\end{equation}


\begin{equation}
\begin{array} {lllrrr} 
\displaystyle \operatorname*{arg\,min}_\pi & \displaystyle\sum_{i = 1}^n C_{\pi}(x_{ij})x_{ij} \\\\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} T(x)^{f_k^i} Y_x^{f_k^i} & \leq &  D_{\textbf{F}} \\
& \displaystyle\sum_{j = 1}^{n_i} x_{ij} & = & 1 & \forall i \in \lbrace 0, n \rbrace \\\\
& x_{ij} \in \lbrace 0, 1 \rbrace &&
\end{array}
\end{equation}
















