
\begin{equation}
\begin{array} {lllrr} 
\text{min} & \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} g(x)^{f_k^i} Y_x^{f_k^i} \\\\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} T(x)^{f_k^i} Y_x^{f_k^i} & \leq &  D_{\textbf{F}} \\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} Y_x^{f_k^i} & = & 1 \\\\
& Y_x^{f_k^i} \in \lbrace 0, 1 \rbrace &&
\end{array}
\end{equation}


\begin{equation}
\begin{array} {lllrr} 
\text{min} & \displaystyle\sum_{\pi \in \Pi} \sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} g(x)^{f_k^i} Y_{(\pi, x)}^{f_k^i} \\\\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} T(x)^{f_k^i} Y_x^{f_k^i} & \leq &  D_{\textbf{F}} \\
& \displaystyle\sum_{\pi \in \Pi} \sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} Y_{(\pi, x)}^{f_k^i} & = & 1 \\\\
& Y_{(\pi, x)}^{f_k^i} \in \lbrace 0, 1 \rbrace &&
\end{array}
\end{equation}


\newpage

\section{Serverless Computing Paradigm}

In serverless computing platforms, computation is done by so-called \textit{function instances} which are completely managed by the serverless computing platform provider and act as tiny servers that can be invoked based on events forwarded by end-users \cite{PMSCP}.

Serverless computing platforms handle almost every aspect of the system administration tasks needed to deploy a workload on the cloud, providing a new simplified programming model according to which developers can focus on the business aspects of their applications only \cite{COSE}.

Moreover, the paradigm lowers the cost of deploying applications too, adopting a so-called “\textit{pay as you go}” pricing model, by charging for execution time rather than for allocated resources \cite{COSE}.


\subsection{Serverless Function}

A \textit{serverless function} represents a stateless, event-driven, self-contained unit of computation implementing a business functionality.

Although a serverless function generally represents a unit of executable code, submitted to FaaS platforms by developers using one or a combination of the programming languages supported by FaaS providers, a serverless function can be any cloud services eventually necessary to business logic, like cloud storage, message queue services, pub/sub messaging service etc.

When it represents executable code, developers can specify several configuration parameters, like timeout, memory size or CPU power \cite{COSE}.

A serverless function can be triggered through events or HTTP requests following which the FaaS provider executes it in a containerized environment, like container, virtual machine or even processes, using the specified configuration.

\subsection{Serverless Application}

A \textit{serverless application} represents a stateless and event-driven software system made up of a set of serverless functions hosted on one or more FaaS platforms and combined together by an \textit{orchestrator}, which handles events among functions and triggers them in the correct order according to the business logic defined by developers. 

\section{Orchestrator Model}

\subsection{Resource owner}

A \textit{resource owner}, henceforward denoted with $R$, represents an entity capable of \textit{creating}, \textit{modifying} and \textit{authorizing} access to several resources of our system.

\section{Serverless Choreography}

According to our framework, a \textit{serverless choreography} is a \textit{resource} used to model and implement both serverless functions and serverless applications.

Informally, a serverless choreography is derived by the control-flow graph which describes, using graph notation, all paths that might be traversed through a serverless application during its execution. Similarly, a serverless choreography describes calling relationships between serverless functions which can be combined using several types of control-flow connectors.

\subsection{Definition}

Formally, let $n \in \N \setminus \left\lbrace 0 \right\rbrace $, being $R$ the resource owner, a \textit{serverless choreography}, or simply \textit{choreography}, $\mathcal{S}_R$ owned by $R$ is a weighted directed graph defined as follows:

\begin{equation}
	\mathcal{S}_R \mathDef (\Phi,E)
\end{equation}

where:

\begin{itemize}
	\item $\Phi$ represents a finite set of vertices such that $|\Phi|=n$. 
	
	Each vertex $\phi \in \Phi$ is called \textit{abstract serverless function} which represents, generally, a computational unit; we will describe more in detail what we mean by abstract serverless function shortly;
	
	\item $E \subseteq \Phi \times \Phi $ represents a finite set of directed edges.
	
	For all $i,j \in \left[ 1, n \right]$, each directed edge from $\phi_i \in \Phi$ to $\phi_j \in \Phi$, denoted as $\left( \phi_i, \phi_j \right)$, indicates that the abstract serverless function $\phi_j$ \textit{can} be called by $\phi_i$, representing the interaction between $\phi_i$ and $\phi_j$ defined by the business logic;
	
	\item For all $i,j \in \left[ 1, n \right]$, the number $p_{ij} \in \left[ 0, 1 \right]$ is the weight assigned to the edge $\left(\phi_i, \phi_j \right)$ and represents the \textit{transition probability} from $\phi_i$ to $\phi_j$, that is the probability of invoking $\phi_j$ after finishing the execution of $\phi_i$.
	
	$P : \Phi \times \Phi \to \left[ 0, 1 \right]$ is defined as the \textit{transition probability function} according to which $P\left(\phi_i, \phi_j \right) = p_{ij}$. Clearly, when $P\left(\phi_i, \phi_j \right) = 0$, the directed edge $\left( \phi_i, \phi_j \right)$ does not exist according to business logic, therefore $\phi_i$ cannot invoke $\phi_j$;
	
\end{itemize} 

A choreography $\mathcal{S}_R$ can be uniquely identified by an ordered pair $(a, b)$, where $a$ is the name of the resource owner $R$, while $b$ is the function choreography name.

Clearly, we say that choreography models a serverless function when $|\Phi| = 1$ and $|E| = 0$; conversely, it models a serverless function application when $|\Phi| > 1$ and $|E| > 0$.

From now, a choreography $\mathcal{S}_R$ will be briefly denoted by $\mathcal{S}$ when no confusion can arise about the resource owner $R$.

\subsubsection{Notations}

Let $\mathcal{S} = (\Phi,E)$ a choreography. Let's now introduce following notations and functions:

\begin{itemize}
	\item A \textit{path} $\pi$ is defined as a finite sequence of distinct vertices and edges as follows:
	
	\begin{equation}
	\pi = \phi_1 e_1 \phi_2 e_2 \ldots e_{n-2}\phi_{n-1} e_{n-1} \phi_n
	\end{equation}
	 
	where:
	
	\begin{itemize}
		\item $\phi_i \in \Phi$, for all $i \in \left[ 1, n \right]$
		\item $e_i = \left( \phi_i, \phi_{i+1} \right) \in E$, for all $i \in \left[ 1, n-1 \right]$
	\end{itemize}
	
	\item Given a path $\pi$, we define the \textit{transition probability} of the path $\pi$ the following quantity:
	
	\begin{equation}
		TPP(\pi) = \prod_{i = 1}^{n-1} P\left(\phi_i, \phi_{i+1} \right)
	\end{equation}

	\item Let $\phi_i \in \Phi$ to $\phi_j \in \Phi$ for all $i,j \in \left[ 1, n \right]$, the set $\Pi(\phi_i, \phi_j)$ identifies all possible paths starting from vertex $\phi_i$ and ending at vertex $\phi_j$.
	
	\item The set $out(\phi_u)$ ($in(\phi_u)$) denotes all edges starting (ending) from (to) vertex $\phi_u$, while the set $succ(\phi_u)$ ($pred(\phi_u)$) includes all direct successor (predecessors) vertices of $\phi_u$. Formally:
	
	\begin{eqnarray}\label{outDef}
		out(\phi_u) & \mathDef & \left\lbrace (\phi_u, \phi) \in E, \quad \forall \phi \in \Phi  \right\rbrace \\
		in(\phi_u) & \mathDef & \left\lbrace (\phi, \phi_u) \in E, \quad \forall \phi \in \Phi  \right\rbrace \\
		succ(\phi_u) & \mathDef & \left\lbrace \phi \in \Phi \mid (\phi_u, \phi) \in out(\phi_u)  \right\rbrace \\
		pred(\phi_u) & \mathDef & \left\lbrace \phi \in \Phi \mid (\phi, \phi_u) \in in(\phi_u)  \right\rbrace 
	\end{eqnarray}
	
	\item $NI: \Phi \to \left[ 0, \infty \right)$ is a function representing the average number of invocations of an abstract serverless function $\phi \in \Phi$ during the execution of a serverless choreography $\mathcal{S}$.
	
	\item $D : \Phi \times \Phi \to \left[ 0, \infty \right)$ represents a delay function according to which $D\left(\phi_i, \phi_j \right)$ identifies the delay from $\phi_i$ to $\phi_j$ due to network delay or orchestration task;  
	
\end{itemize}

\subsection{Abstract Serverless Function}

Supposing that a choreography $\mathcal{S} = (\Phi,E)$ is given, an \textit{abstract serverless function} $\phi \in \Phi$, or simply \textit{abstract function}, is a \textit{resource} that represents a computational unit needed by business logic. 

According to our model, there are two types of abstract functions implementations:

\begin{itemize}
	
	\item $\phi$ is defined as \textit{serverless executable functions}, or simply \textit{executable function}, when $\phi$ contains executable code which implementing business logic.
	
	$\mathscr{F_E}$ is defined as the set containing all executable function of $\mathcal{S}$ and it is formally defined as follows:
	
	\begin{equation}
		\mathscr{F_E} \mathDef \left\lbrace \phi \in \Phi \mid \phi \text{ is a serverless executable function }\right\rbrace 
	\end{equation}
	
	However, multiple different implementations of a given executable function can be provided by developers which, although they must be semantically and logically equivalent, may eventually expose different performance or cost behavior. 
	
	Therefore, for each $\phi \in \mathscr{F_E}$, the set $\textbf{F}_{\phi}$, containing all implementations of $\phi$, generally denoted by $f_{\phi}$, such that $|\textbf{F}| \geq 1 $, must exist.

	We will explain later that the aim of our framework is to pick exactly one $f_{\phi} \in \textbf{F}_{\phi}$ whose properties allow us to meet user-specified QoS objective.
	
	We assume that every $f_{\phi} \in \textbf{F}_{\phi}$ for all $\phi \in \mathscr{F_E}$ is already deployed on one or more FaaS platform by developers.
		
	\item $\phi$ is called \textit{serverless orchestration functions}, or \textit{orchestration functions}, when $\phi$ contain orchestration code needed to decide which and how the next abstract functions must be called; in other words, orchestration code is control-flow code.
	
	$\mathscr{F_O}$ is defined as the set containing all executable function of $\mathcal{S}$ and it is formally defined as follows:
	
	\begin{equation}
		\mathscr{F_O} \mathDef \left\lbrace \phi \in \Phi \mid \phi \text{ is a serverless orchestration function }\right\rbrace 
	\end{equation}

	
\end{itemize}

Clearly, based on above definition, we can say: 

\begin{eqnarray}
\mathscr{F_E} \cap \mathscr{F_O} & = & \emptyset \\
\mathscr{F_E} \cup \mathscr{F_O} & = & \Phi \\
|\mathscr{F_E}| + |\mathscr{F_O}| &=& |\Phi| 
\end{eqnarray}

Any abstract function $\phi$ is uniquely identified by an ordered pair $(a, b)$, where:
\begin{itemize}
	\item $a$ represents the identifier of the choreography $\mathcal{S}$;
	\item $b$ is the name of the abstract serverless function $\phi$;
\end{itemize}

% Generally it contains the description of what the corresponding implementation does including several proprieties, like input or output data types.

\subsubsection{Special Abstract Serverless Functions} 

According to the serverless paradigm, the execution of a serverless application starts with a particular function, which we will denote as the \textit{entry point}, while any other serverless functions, belonging to the application, will be invoked subsequently according to specified business logic. 

Clearly, the execution of a serverless application ends when ends the execution of the last function according to the business logic. That ending function will be denoted as \textit{end point}. According to our point of view, the end point is not unique.

In order to appropriately model a serverless application, any choreography $\mathcal{S}$ has two special abstract functions:

\begin{itemize}
	\item One acting as the entry point which is denoted by $\phi_{entry}$;
	\item Another acting as the end point and denoted by $\phi_{end}$;
\end{itemize}

Formally:

\begin{eqnarray}
	\phi_{entry} \in \Phi \text{ is the entry point of } \mathcal{S} & \Leftrightarrow & in(\phi_{entry}) = \emptyset \\
	\phi_{end} \in \Phi \text{ is the end point of } \mathcal{S} & \Leftrightarrow & out(\phi_{end}) = \emptyset
\end{eqnarray}

\subsection{Serverless Choreography Configuration}

Given a choreography $\mathcal{S} = (\Phi,E)$, the basic goal of our framework is to determine the so-called \textit{serverless choreography configuration}, also called \textit{choreography configuration} or simply \textit{configuration}, that allows us to meet user-specified QoS objectives.

Informally, a configuration specifies which implementation $f_{\phi} \in \textbf{F}_{\phi}$, for each $\phi \in \mathscr{F_E}$, will be effectively executed, including its parameters such as memory size or CPU power.

\subsubsection{Serverless Functions Configuration}

Let $\phi \in \mathscr{F_E}$ an executable function and $\textbf{F}_{\phi}$ the corresponding set of serverless functions which implement it. 

We say that a \textit{configuration} for $\phi$ is a vector $x_{\phi} \in \textbf{F}_{\phi} \times \N$. Let $m \in \N$ and supposing that $x_{\phi} = (f_{\phi},m)$, $f_{\phi}$ represents a particular serverless function implementing $\phi$ while $m$ represents the allocated memory size of $f_{\phi}$.

At this point, we can define some useful functions:

\begin{itemize}	
	\item $C_{\textbf{F}_{\phi}} : \textbf{F}_{\phi} \times \N \to \left[ 0, \infty \right)$ is the cost function for the serverless functions implementing $\phi$.
	
	To be more precise, for all $f_{\phi} \in \textbf{F}_{\phi}$ and $m \in \N$, $C_{\textbf{F}_{\phi}}(f_{\phi}, m)$ returns the average cost paid by developers to execute $f_{\phi}$ using an allocated memory size equal to $m$.
	
	
	\item $RT_{\textbf{F}_{\phi}} : \textbf{F}_{\phi} \times \N \to \left[ 0, \infty \right)$ is a delay function for the serverless functions implementing $\phi$.
	
	For all $f_{\phi} \in \textbf{F}_{\phi}$ and $m \in \N$, $RT_{\textbf{F}_{\phi}}(f_{\phi}, m)$ returns the average response time when $f_{\phi}$ is invoked with memory size equal to $m$;
\end{itemize}

\subsubsection{Serverless Choreography Configuration}

Let $n,k \in \N$ and a choreography $\mathcal{S} = (\Phi,E)$ such that $|\Phi| = n$ and $|\mathscr{F_E}| = k$ where $k \leq n$.

Formally, a configuration for $\mathcal{S}$ is a vector $\textbf{X}$ such that:

\begin{equation}
\textbf{X} \in \lbrace \textbf{F}_{\phi_{1}} \times \mathbb{N} \rbrace \times \ldots \times \lbrace \textbf{F}_{\phi_{k}} \times \mathbb{N} \rbrace = \Cross_{i = 1}^k \lbrace \textbf{F}_{\phi_{i}} \times \mathbb{N} \rbrace
\end{equation}

For all $i \in \left[ 1, k \right]$, supposing that $\textbf{X} = \left\lbrace x_{\phi_{1}}, \ldots, x_{\phi_{k}} \right\rbrace $, $x_{\phi_{i}}$ is a configuration for $\phi_{i}$; we will use $X(i)$ notation as a reference to the configuration $x_{\phi_{i}}$ while we will use $X(i,1)$ and $X(i,2)$ to denote respectively the implementation $f \in \textbf{F}_{\phi_i}$ and the allocated memory size $m \in N$ for the function $f$.

\subsection{Metrics}

Let $\mathcal{S} = (\Phi,E)$ a choreography such that:
\begin{itemize}
	\item $\mathcal{S}$ is a DAG without any cycles or loops;
	\item Is true that the transition probabilities of all paths between the entry point and
	the end point of $\mathcal{S}$ can sum up to $1$. Formally:
	
	\begin{equation}
		\sum_{\pi \in \Pi(\phi_{entry}, \phi_{end})} TPP(\pi) = 1
	\end{equation}

\end{itemize}

Suppose to have a path $\pi = \phi_1 e_1 \phi_2 e_2 \ldots e_{n-2}\phi_{n-1} e_{n-1} \phi_n$ and a choreography configuration $\textbf{X}$ for $\mathcal{S}$. 

We can define the \textit{response time} of $\pi$ given $\textbf{X}$ as follows:

\begin{equation}
	RT_P(\pi, \textbf{X}) = \sum_{i = 1}^n \left(  N(\phi_i) \cdot RT_{\phi_i} (X(i) \right)  + \sum_{i = 1}^{n-1} N(\phi_i) \cdot D(\phi_i,\phi_{i+1})
\end{equation}

Similarly, we define the cost of $\pi$ given $\textbf{X}$ as follows:

\begin{equation}
	C_P(\pi, \textbf{X}) = \sum_{\substack{1\le i\le n\\ \phi_i \in \mathscr{F_E}}} N(\phi_i) \cdot C_{\textbf{F}_{\phi_i}} (X(i))
\end{equation}


Then the response time and the cost of the choreography $\mathcal{S}$ a follows:

\begin{eqnarray}
	RT_C(\mathcal{S}, \textbf{X}) & = & \sum_{\pi \in \Pi(\phi_{entry}, \phi_{end})} TPP(\pi) \cdot RT_{P}(\pi, \textbf{X}) \\
	C_C(\mathcal{S}, \textbf{X}) & = & \sum_{\pi \in \Pi(\phi_{entry}, \phi_{end})} TPP(\pi) \cdot C_{P}(\pi, \textbf{X}) 
\end{eqnarray}

\subsection{Serverless Sub-choreography}

For any given serverless choreography $\mathcal{S} = (\Phi,E)$, is possible to identify a \textit{serverless sub-choreography}, or simply \textit{sub-choreography}, denoted by $S^*$, which is a weighted directed sub-graph of $\mathcal{S}$ formally as follows:

\begin{equation}
	S^* \mathDef (\Phi^*,E^*) \qquad \text{ where } \Phi^* \subseteq \Phi \wedge E^* \subseteq E
\end{equation}

Through $\phi_{start}^* \in \Phi^*$ and $\phi_{end}^* \in \Phi^*$ notation we denote, respectively, the \textit{entry point} and the \textit{end point} of the sub-choreography $S^*$.

\subsection{Structures}

Supposing to have a serverless choreography $\mathcal{S} = (\Phi,E)$, we call \textit{structure} any sub-choreography $\mathcal{S}^*= (\Phi^*,E^*)$ whose entry point and the end point are, respectively, an opening and a closing orchestration functions of the same type. Formally:

\begin{equation}
	S^* \text{ is a structure } \Leftrightarrow \left\{ \begin{array}{rlll}
		\phi_{entry}^* & \in \mathscr{F_O^*} & \wedge & \mathscr{T}(\phi_{entry}^*) = \tau_{\alpha} \\ 
		\phi_{end}^* & \in \mathscr{F_O^*} & \wedge & \mathscr{T}(\phi_{end}^*) = \tau_{\omega}
	\end{array} \right.
\end{equation}

The most important aspect is that every structure can be viewed as a set of sub-choreographies of $\mathcal{S}^*$. Formally, suppose that $\Lambda = (A,B)$ is a graph such that:

\begin{equation}
\begin{array}{lll}
	A & \mathDef & \Phi^* \setminus \left\lbrace \phi_{entry}^*,\phi_{end}^* \right\rbrace   \\
	B & \mathDef & E^* \setminus \left( out\left(\phi_{entry}^*\right) \cup in\left(\phi_{end}^*\right) \right)
\end{array}
\end{equation}

Let $c \in \N$ and suppose that $c$ is the number of connected components of the graph $\Lambda$.

We denote by $\Theta_{\mathcal{S}^*}$ as the set containing all connected components of $\Lambda$ every of which is considered as a sub-choreography of $\mathcal{S}^*$. Formally:

\begin{equation}
	\begin{array}{c}
		\Theta_{\mathcal{S}^*} \mathDef \left\lbrace \theta_i, \ldots ,\theta_c \right\rbrace \\\\
		\text{ where } \\\\
		
		\theta_i \mathDef (\Phi^{**}_i, E^{**}_i) \text{ is a sub-choreography of } \mathcal{S}^* \\
		 \Phi^{**}_i \subset \Phi^{*} \wedge E^{**}_i \subset E^{*} \qquad \forall i \in \left[ 1, c \right] \\
	\end{array}
\end{equation} 

\subsubsection{Parallel}

A structure $\mathcal{P} = (\Phi,E,\Theta)$ is called \textit{parallel structure} when:

\begin{equation}
	TPP(\pi) = 1 \qquad \forall \pi \in \Pi(\phi_{start}, \phi_{end})
\end{equation}

Let $n \in \N$, supposing that $|\Theta| = n$, the response time of a parallel structure is the longest response time of all sub-choreographies $\theta_i \in \Theta$ for all $i \in \left[ 1, n \right]$, while its cost is equal to the sum their costs of execution. Formally, being $\textbf{X}$ a configuration of  $\mathcal{P}$:

\begin{equation}
	RT_{parallel}(\mathcal{P}, \textbf{X}) = max \left\lbrace RT_C(\mathcal{\theta}, \textbf{X}) \mid \theta \in \Theta \right\rbrace 
\end{equation}

\begin{equation}
	C_{parallel}(\mathcal{P}, \textbf{X}) = \sum_{\theta \in \Theta} C_C(\theta, \textbf{X})
\end{equation}



\subsubsection{Branch}

We say that A sub-choreography $\mathcal{B}$, such that $\phi_{start}' = \phi_i$ and $\phi_{end}' = \phi_j$, is called \textit{branch structure} when:

\begin{equation}
	\begin{array}{c}
	TPP(\pi) \neq 1 \qquad \forall \pi \in \Pi(\phi_{start}^*, \phi_{end}^*) \\
	\wedge \\
	\displaystyle\sum_{\pi \in \Pi(\phi_{start}^*, \phi_{end}^*)} TPP(\pi) = 1
	\end{array}
\end{equation}


\section{Optimization}


\subsection{Performance Modeling}






We define the utility function as follows:

\begin{equation}
	F(\textbf{x}) \mathDef w_{RT} \cdot \dfrac{RT_{max} - RT(\textbf{x})}{RT_{max} - RT_{min}} + w_{C} \cdot \dfrac{C_{max} - C(\textbf{x})}{C_{max} - C_{min}}
\end{equation}

where $w_{RT}, w_{C} \geq 0$, $w_{RT} + w_{C} = 1$, are weights for the different QoS attributes, while $RT_{max}$ ($RT_{min}$) and $C_{max}$ ($C_{min}$) denote, respectively, the maximum (minimum) value for the overall expected response time and cost.






Before to proceed, when the serverless workflow configuration $x$ is used,




\begin{itemize}
	\item $D(\textbf{x})$ denotes the end-to-end response time of current serverless workflow $G_s$ when the serverless workflow configuration $x$ is used. At the same time, $C(\textbf{x})$ represents the  
	\item $C(\textbf{x})$ re
\end{itemize}

gdfgdfgdfgd

\begin{itemize}
	\item $\textbf{x}(\mathscr{F})$ is used to denote the configuration $\left( f, m \right) $ of the serverless abstract function $\mathscr{F}$.
	\item $C_{func}(\textbf{x}(\mathscr{F}))$ represents the cost to pay to execute the concrete serverless function $f$ with memory size $m$.
\end{itemize}



\begin{equation}
	C_{walk}(w, \textbf{x}) = \sum_{\mathscr{F} \in w} C_{func}(\textbf{x}(\mathscr{F}))
\end{equation}


\begin{equation}
	C_{conf}(\textbf{x}) = \sum_{w \in SP_{G_s}(\mathscr{F}_{start}, \mathscr{F}_{end})} TPP(w) C(w, \textbf{x})
\end{equation}


\begin{equation}
\begin{array} {lllrrr} 
\displaystyle \operatorname*{arg\,min}_\pi & \displaystyle\sum_{i = 1}^n C_{\pi}(x_{ij})x_{ij} \\\\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} T(x)^{f_k^i} Y_x^{f_k^i} & \leq &  D_{\textbf{F}} \\
& \displaystyle\sum_{j = 1}^{n_i} x_{ij} & = & 1 & \forall i \in \lbrace 0, n \rbrace \\\\
& x_{ij} \in \lbrace 0, 1 \rbrace &&
\end{array}
\end{equation}
















