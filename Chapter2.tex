
\begin{equation}
\begin{array} {lllrr} 
\text{min} & \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} g(x)^{f_k^i} Y_x^{f_k^i} \\\\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} T(x)^{f_k^i} Y_x^{f_k^i} & \leq &  D_{\textbf{F}} \\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} Y_x^{f_k^i} & = & 1 \\\\
& Y_x^{f_k^i} \in \lbrace 0, 1 \rbrace &&
\end{array}
\end{equation}


\begin{equation}
\begin{array} {lllrr} 
\text{min} & \displaystyle\sum_{\pi \in \Pi} \sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} g(x)^{f_k^i} Y_{(\pi, x)}^{f_k^i} \\\\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} T(x)^{f_k^i} Y_x^{f_k^i} & \leq &  D_{\textbf{F}} \\
& \displaystyle\sum_{\pi \in \Pi} \sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} Y_{(\pi, x)}^{f_k^i} & = & 1 \\\\
& Y_{(\pi, x)}^{f_k^i} \in \lbrace 0, 1 \rbrace &&
\end{array}
\end{equation}


\newpage

\section{Serverless Computing Paradigm}

In serverless computing platforms, computation is done by so-called \textit{function instances} which are completely managed by the serverless computing platform provider and act as tiny servers that can be invoked based on events forwarded by end-users \cite{PMSCP}.

Serverless computing platforms handle almost every aspect of the system administration tasks needed to deploy a workload on the cloud, providing a new simplified programming model according to which developers can focus on the business aspects of their applications only \cite{COSE}.

Moreover, the paradigm lowers the cost of deploying applications too, adopting a so-called “\textit{pay as you go}” pricing model, by charging for execution time rather than for allocated resources \cite{COSE}.


\subsection{Serverless Function}

A \textit{serverless function} represents a stateless, event-driven, self-contained unit of computation implementing a business functionality.

Although a serverless function generally represents a unit of executable code, submitted to FaaS platforms by developers using one or a combination of the programming languages supported by FaaS providers, a serverless function can be any cloud services eventually necessary to business logic, like cloud storage, message queue services, pub/sub messaging service etc.

When it represents executable code, developers can specify several configuration parameters, like timeout, memory size or CPU power \cite{COSE}.

A serverless function can be triggered through events or HTTP requests following which the FaaS provider executes it in a containerized environment, like container, virtual machine or even processes, using the specified configuration.

\subsection{Serverless Application}

A \textit{serverless application} represents a stateless and event-driven software system made up of a set of serverless functions hosted on one or more FaaS platforms and combined together by an \textit{orchestrator}, which handles events among functions and triggers them in the correct order according to the business logic defined by developers. 

\section{Orchestrator Model}

\subsection{Resource owner}

A \textit{resource owner}, henceforward denoted with $R$, represents an entity capable of \textit{creating}, \textit{modifying} and \textit{authorizing} access to several resources of our system.

\section{Serverless Choreography}

According to our framework, a \textit{serverless choreography} is a \textit{resource} used to model and implement both serverless functions and serverless applications.

Informally, a serverless choreography is derived by the control-flow graph which describes, using graph notation, all paths that might be traversed through a serverless application during its execution. Similarly, a serverless choreography describes calling relationships between serverless functions which can be combined using several types of control-flow connectors.

\subsection{Definition}

Formally, let $n \in \N \setminus \left\lbrace 0 \right\rbrace $, being $R$ the resource owner, a \textit{serverless choreography}, or simply \textit{choreography}, is a weighted directed graph defined as follows:

\begin{equation}
	SC_R \mathDef (\Phi,E)
\end{equation}

where:

\begin{itemize}
	\item $\Phi$ represents a finite set of $n$ vertices where each vertex $\phi \in \Phi$ represents a so-called \textit{abstract serverless function} such that $\Phi = \left\lbrace \phi_1, \phi_2, ..., \phi_{n-1}, \phi_n \right\rbrace$. We will describe what we mean by abstract serverless function shortly;
	
	\item $E \subseteq \Phi \times \Phi $ represents a finite set of directed edges where, for all $i,j \in \left[ 1, n \right]$, each directed edge from $\phi_i \in \Phi$ to $\phi_j \in \Phi$, denoted as $\left( \phi_i, \phi_j \right)$, indicates that the abstract serverless function $\phi_j$ \textit{can} be called by $\phi_i$;
	
	In other words, each directed edge represents the interaction between $\phi_i$ and $\phi_j$ defined by the business logic;
\end{itemize} 

A serverless choreography $SC_R$ can be uniquely identified by an ordered pair $(a, b)$, where $a$ is the name of the resource owner $R$, while $b$ is the function choreography name.

Clearly, we say that a serverless choreography models a serverless function when $|\Phi| = 1$ and $|E| = 0$; conversely, it models a serverless function application when $|\Phi| > 1$ and $|E| > 0$.

\subsubsection{Notations}

Based on the definition of the serverless choreography given before, will be very useful introduce following notations and functions:

\begin{itemize}
	\item Resuming graph theory, we call \textit{path} a finite sequence of distinct vertices and edges $\pi = \phi_1 e_1 \phi_2 e_2 \ldots e_{n-2}\phi_{n-1} e_{n-1} \phi_n$ such that:
	
	\begin{itemize}
		\item $\phi_i \in \Phi$, for all $i \in \left[ 1, n \right]$
		\item $e_i \in E$, for all $i \in \left[ 1, n-1 \right]$
		\item $e_i = \left( \phi_i, \phi_{i+1} \right)$ for all $i \in \left[ 1, n-1 \right]$
	\end{itemize}
	
	\item Given a path $w$, we define the transition probability of the path $w$ the following quantity:
	
	\begin{equation}
		TPP(\pi) = \prod_{i = 1}^{n-1} P\left(\phi_i, \phi_{i+1} \right)
	\end{equation}

	\item Let $\phi_i \in \Phi$ to $\phi_j \in \Phi$ for all $i,j \in \left[ 1, n \right]$, the set $\Pi(\phi_i, \phi_j)$ identifies all possible paths starting from $\pi$ and ending at vertex $\phi_i$ and vertex $\phi_j$, extremes included, inside the $(\Phi,E)$ graph.
	
	\item The set $out(\phi_u)$ denotes all edges starting from vertex $\phi_u$. Formally: 
	
	\begin{equation}\label{outDef}
		out(\phi_u) \mathDef \left\lbrace e \in E \mid e = (\phi_u, \phi) \text{ for some } \phi \in \Phi  \right\rbrace 
	\end{equation}

	Conversely, the set $in(\phi_u)$ denotes all edges ending to vertex $\phi_u$, that is:

	\begin{equation}\label{outDef}
	in(\phi_u) \mathDef \left\lbrace e \in E \mid e = (\phi, \phi_u) \text{ for some } \phi \in \Phi  \right\rbrace 
	\end{equation}

	\item The set $succ(\phi_u)$ denotes the set of all \textit{direct successor} vertices of $\phi_u$. More precisely:
	
	\begin{equation}\label{outDef}
		succ(\phi_u) \mathDef \left\lbrace \phi \in \Phi \mid \phi \text{ is head of some } e = (\phi_u, \phi) \in out(\phi_u)  \right\rbrace 
	\end{equation}

	The set $pred(\phi_u)$ includes all \textit{direct predecessor} vertices of $\phi_u$. Formally: 
	
	\begin{equation}\label{outDef}
		pred(\phi_u) \mathDef \left\lbrace \phi \in \Phi \mid \phi \text{ is tail of some } e = (\phi, \phi_u) \in in(\phi_u)  \right\rbrace 
	\end{equation}
	
	
	\item $P : \Phi \times \Phi \to \left[ 0, 1 \right]$ is a the transition probability function according to which, for all $i,j \in \left[ 1, n \right]$, $P\left(\phi_i, \phi_j \right)$ represents the probability of invoking $\phi_j$ after finishing the execution of $\phi_i$. 
	
	Clearly, when $P\left(\phi_i, \phi_j \right) = 0$, the directed edge $\left( \phi_i, \phi_j \right)$ does not exist according to business logic, therefore $\phi_i$ cannot invoke $\phi_j$;
	
	\item $NI: \Phi \to \left[ 0, \infty \right)$ is a function representing the average number of invocations of any abstract serverless $\phi \in \Phi$ during an execution of a serverless choreography $SC_R$.
	
	\item $D : \Phi \times \Phi \to \left[ 0, \infty \right)$ represents a delay function according to which $D\left(\phi_i, \phi_j \right)$ identifies the delay from $\phi_i$ to $\phi_j$ due to network delay or orchestration task;  
	
\end{itemize}

\subsubsection{Abstract Serverless Function}

An abstract serverless function $\phi$, or simply abstract function, is a resource that represents a template of a computational unit needed for business logic building, containing the description of what the corresponding implementation does including several proprieties, like input or output data types.

According to serverless paradigm, the execution of a serverless choreography starts with a particular abstract function $\phi_{start} \in \Phi$ which acts as \textit{entry point}; any other abstract functions belonging to the choreography will be invoked subsequently according to specified business logic. Similarly, any serverless choreography execution terminates with a particular abstract function $\phi_{end} \in \Phi$ which acts as \textit{end point}.

According to our model, there are two types of abstract serverless functions:

\begin{description}
	
	\item[Abstract Executable Serverless Functions] they represent computational units containing executable code implementing business logic. The set of all abstract executable serverless functions is denoted by $\mathscr{F_E}$.
	
	To be more precise, developers can provide different implementations of a given abstract executable serverless function $F \in \mathscr{F_E}$ which, although they must be semantically equivalent, may eventually expose different performance or cost behavior. Therefore is said that any $F \in \mathscr{F_E}$ contains a set $\textbf{F}$, such that $|\textbf{F}| \geq 1 $, containing serverless functions $f$ which we assume already deployed on one or more FaaS platform by developers.
	
	\item[Abstract Serverless Orchestration Functions] Their set is denoted by $\mathscr{F_O}$ and they contain orchestration code used to connect any abstract serverless function together in order to alter the control-flow of serverless choreography according to the actual values of data passed to them.
	
\end{description}

Formally: 

\begin{equation}
\Phi \mathDef \mathscr{F_E} \cup \mathscr{F_O} \qquad \text{ where } |\mathscr{F_E}| + |\mathscr{F_O}| = n
\end{equation}

\subsection{Configuration}

Given a choreography $SC_R = (\Phi,E)$, the basic goal of our framework is to determine the so-called \textit{serverless choreography configuration}, or simply \textit{configuration}, of $SC_R$ that allows us to meet user-specified QoS objectives.

\subsubsection{Serverless Functions Configuration}

Let an abstract executable serverless function $\mathscr{F_E}$ and \textbf{F} the corresponding set of serverless function which implement it, we define the following vector:

\begin{equation}
	x \in \textbf{F} \times \N
\end{equation}

as the \textit{serverless functions configuration}, or simply \textit{configuration}, of $\mathscr{F_E}$. In this context, for any $f \in \textbf{F}$ and $m \in \N$, given $x =(f,m)$, $f$ represents a particular serverless function while $m$ represents the allocated memory size.

At this point, we can define some useful functions:

\begin{itemize}	
	\item $C_{\textbf{F}} : \textbf{F} \times \N \to \left[ 0, \infty \right)$ which represents a cost function for serverless functions. For any $f \in \textbf{F}$ and $n \in \N$, $C_{\textbf{F}}(f,n)$ returns the average cost paid by developers to execute $f$ using an allocated memory size equal to $n$.
	
	\item $RT_{\textbf{F}} : \textbf{F} \times \N \to \left[ 0, \infty \right)$ which represents a delay function for serverless functions. For any $f \in \textbf{F}$ and $n \in \N$, $RT_{\textbf{F}}(f,n)$ returns the average response time of function $f$ using $n$ as allocated memory size.
\end{itemize}

Any abstract serverless function is uniquely identified by an ordered string tuple $(a, b, c)$, where:
\begin{itemize}
	\item $a$ represents the name of the resource owner $R$;
	\item $b$ represents the name of the serverless choreography $SC_R$;
	\item $c$ is the name of the abstract serverless function $\phi$
\end{itemize}

\subsubsection{Serverless Choreography Configuration}

Let $n,k \in \N$, such that $k \leq n$, and $SC_R$ a serverless choreography where $|\Phi| = n$ and $|\mathscr{F_E}| = k$. 

The basic goal of our framework is to determine a so-called \textit{serverless choreography configuration} that allows us to meet user-specified QoS objectives. Formally, a serverless choreography configuration $\textbf{x}$ is a $k\times2$ matrix such that:

\begin{equation}
\textbf{X} \in \lbrace \textbf{F}_1 \times \mathbb{N} \rbrace \times \ldots \times \lbrace \textbf{F}_k \times \mathbb{N} \rbrace = \Cross_{i = 1}^k \lbrace \textbf{F}_i \times \mathbb{N} \rbrace
\end{equation}

In other words, $\textbf{x}$ is a matrix where, for $i \in \left[ 1, k \right]$, the $i$-th row contains a serverless functions configuration for the abstract executable serverless functions $F_i \in \mathscr{F_E}$. 

More precisely, for $v \in \left[ 1, k \right]$, the matrix $\textbf{X}$ is such that:

\begin{itemize}
	\item the element $(v,1)$ identifies the serverless function $f \in \textbf{F}_v$ which implements the abstract executable serverless function $F_v \in \mathscr{F_E}$;
	
	\item the element $(v,2)$ identifies the allocated memory size $m \in N$ of the serverless function identified by the element $(v,1)$.
\end{itemize}

\subsection{Metrics}

Let $\mathcal{C} = (\Phi,E)$ a choreography such that:
\begin{itemize}
	\item $\mathcal{C}$ is a DAG without any cycles and loops;
	\item Is true that the transition probabilities of all paths between the start point and
	the end point of $\mathcal{C}$ can sum up to $1$:
	
	\begin{equation}
		\sum_{\pi \in \Pi(\phi_{start}, \phi_{end})} TPP(\pi) = 1
	\end{equation}

\end{itemize}

At this point, let $\pi = \phi_1 e_1 \phi_2 e_2 \ldots e_{n-2}\phi_{n-1} e_{n-1} \phi_n$ a path. We define the response time of $\pi$ as follows:

\begin{equation}
	RT_P(\pi, \textbf{X}) = \sum_{\substack{1\le i\le n\\ \phi_i \in \mathscr{F_E}}} N(\phi_i) \cdot RT_{\textbf{F}} (X_{\phi_{i}1},X_{\phi_{i}2}) + \sum_{i = 1}^{n-1} N(\phi_i) \cdot D(\phi_i,\phi_{i+1})
\end{equation}

Let $\textbf{X}$ a configuration of the choreography $\mathcal{C}$, the response time of $\mathcal{C}$ is defined as follows:

\begin{equation}
	RT_C(\mathcal{C}, \textbf{X}) = \sum_{\pi \in \Pi(\phi_{start}, \phi_{end})} TPP(\pi) \cdot RT_{P}(\pi, \textbf{X})
\end{equation}

\subsection{Structures}

In this section, we will define several types of structures belonging to a given serverless choreography. 

Let $SC_R = (\Phi,E)$ a serverless choreography. We say that a \textit{serverless sub-choreography} $SC_R'$, or simply \textit{sub-choreography}, is a weighted directed sub-graph of $SC_R$. Formally:

\begin{equation}
	SC_R' \mathDef (\Phi',E') \qquad \text{ where } \Phi' \subseteq \Phi \wedge E' \subseteq E
\end{equation}

We denote $\phi_{start}' \in \Phi'$ and $\phi_{end}' \in \Phi'$, respectively, as the \textit{entry point} and the \textit{end point} of the sub-choreography $SC_R'$

\subsubsection{Parallel}

Supposing that a choreography $SC_R = (\Phi,E)$ is given, let us consider two vertices $\phi_i \in \Phi$ and $\phi_j \in \Phi$, for any $i,j \in \left[ 1, n \right]$ such that $i \neq j$.

We say that the sub-choreography $\mathcal{P}$, such that $\phi_{start}' = \phi_i$ and $\phi_{end}' = \phi_j$, is called \textit{parallel structure} when:

\begin{equation}
	TPP(\pi) = 1 \qquad \forall \pi \in \Pi(\phi_{start}^*, \phi_{end}^*)
\end{equation}

Let $out(\phi_{start}^*)$ the set of all edges starting from vertex as defined in equation \ref{outDef} and suppose that $|out(\phi_{start}^*)| = s \in \N \setminus \left\lbrace 0 \right\rbrace $.

Then $\Theta$ is defined as the set, such that $|\Theta| = s$, containing all the sub-choreographies $(\Phi^{**}, E^{**})$ which will be executed at the same time during the processing of the parallel structure. More precisely:

\begin{equation}
	\begin{array}{c}
	\Theta \mathDef \left\lbrace (\Phi^{**}_1, E^{**}_1), \ldots ,(\Phi^{**}_s, E^{**}_s) \right\rbrace \\\\
	\text{ where } \\\\
	\phi_{start_{i}}^{**}, \phi_{end_{i}}^{**} \in \Phi^{**}_i \\\\
	
	\phi_{start_{i}}^{**} \in succ(\phi_{start}^*) \wedge \phi_{end_{i}}^{**} \in pred (\phi_{end}^*) \quad \forall i \in \left[ 1, s \right]
	\end{array}
\end{equation} 

Simply the response time of a parallel structure is the longest response time of all
sub-choreographies $(\Phi^{**}, E^{**})$ in it, while its cost is equal to the sum of costs of execution of all sub-choreographies. Formally, being $\textbf{X}$ a configuration of the choreography $SC_R$:

\begin{equation}
	RT(\mathcal{P}, \textbf{X}) = max \left\lbrace RT(\mathcal{\theta}, \textbf{X}) \mid \theta \in \Theta \right\rbrace 
\end{equation}

\begin{equation}
	C(\mathcal{P}, \textbf{X}) = \sum_{\theta \in \Theta} C(\theta, \textbf{X})
\end{equation}


\section{Optimization}


\subsection{Performance Modeling}






We define the utility function as follows:

\begin{equation}
	F(\textbf{x}) \mathDef w_{RT} \cdot \dfrac{RT_{max} - RT(\textbf{x})}{RT_{max} - RT_{min}} + w_{C} \cdot \dfrac{C_{max} - C(\textbf{x})}{C_{max} - C_{min}}
\end{equation}

where $w_{RT}, w_{C} \geq 0$, $w_{RT} + w_{C} = 1$, are weights for the different QoS attributes, while $RT_{max}$ ($RT_{min}$) and $C_{max}$ ($C_{min}$) denote, respectively, the maximum (minimum) value for the overall expected response time and cost.






Before to proceed, when the serverless workflow configuration $x$ is used,




\begin{itemize}
	\item $D(\textbf{x})$ denotes the end-to-end response time of current serverless workflow $G_s$ when the serverless workflow configuration $x$ is used. At the same time, $C(\textbf{x})$ represents the  
	\item $C(\textbf{x})$ re
\end{itemize}

gdfgdfgdfgd

\begin{itemize}
	\item $\textbf{x}(\mathscr{F})$ is used to denote the configuration $\left( f, m \right) $ of the serverless abstract function $\mathscr{F}$.
	\item $C_{func}(\textbf{x}(\mathscr{F}))$ represents the cost to pay to execute the concrete serverless function $f$ with memory size $m$.
\end{itemize}



\begin{equation}
	C_{walk}(w, \textbf{x}) = \sum_{\mathscr{F} \in w} C_{func}(\textbf{x}(\mathscr{F}))
\end{equation}


\begin{equation}
	C_{conf}(\textbf{x}) = \sum_{w \in SP_{G_s}(\mathscr{F}_{start}, \mathscr{F}_{end})} TPP(w) C(w, \textbf{x})
\end{equation}


\begin{equation}
\begin{array} {lllrrr} 
\displaystyle \operatorname*{arg\,min}_\pi & \displaystyle\sum_{i = 1}^n C_{\pi}(x_{ij})x_{ij} \\\\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} T(x)^{f_k^i} Y_x^{f_k^i} & \leq &  D_{\textbf{F}} \\
& \displaystyle\sum_{j = 1}^{n_i} x_{ij} & = & 1 & \forall i \in \lbrace 0, n \rbrace \\\\
& x_{ij} \in \lbrace 0, 1 \rbrace &&
\end{array}
\end{equation}
















