
\begin{equation}
\begin{array} {lllrr} 
\text{min} & \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} g(x)^{f_k^i} Y_x^{f_k^i} \\\\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} T(x)^{f_k^i} Y_x^{f_k^i} & \leq &  D_{\textbf{F}} \\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} Y_x^{f_k^i} & = & 1 \\\\
& Y_x^{f_k^i} \in \lbrace 0, 1 \rbrace &&
\end{array}
\end{equation}


\begin{equation}
\begin{array} {lllrr} 
\text{min} & \displaystyle\sum_{\pi \in \Pi} \sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} g(x)^{f_k^i} Y_{(\pi, x)}^{f_k^i} \\\\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} T(x)^{f_k^i} Y_x^{f_k^i} & \leq &  D_{\textbf{F}} \\
& \displaystyle\sum_{\pi \in \Pi} \sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} Y_{(\pi, x)}^{f_k^i} & = & 1 \\\\
& Y_{(\pi, x)}^{f_k^i} \in \lbrace 0, 1 \rbrace &&
\end{array}
\end{equation}


\newpage

\section{Serverless Computing Paradigm}

In serverless computing platforms, computation is done by so-called \textit{function instances} which are completely managed by the serverless computing platform provider and act as tiny servers that can be invoked based on events forwarded by end-users \cite{PMSCP}.

Serverless computing platforms handle almost every aspect of the system administration tasks needed to deploy a workload on the cloud, providing a new simplified programming model according to which developers can focus on the business aspects of their applications only \cite{COSE}.

Moreover, the paradigm lowers the cost of deploying applications too, adopting a so-called “\textit{pay as you go}” pricing model, by charging for execution time rather than for allocated resources \cite{COSE}.


\subsection{Serverless Function}

A \textit{serverless function} represents a stateless, event-driven, self-contained unit of computation implementing a business functionality.

Although a serverless function generally represents a unit of executable code, submitted to FaaS platforms by developers using one or a combination of the programming languages supported by FaaS providers, a serverless function can be any cloud services eventually necessary to business logic, like cloud storage, message queue services, pub/sub messaging service etc.

When it represents executable code, developers can specify several configuration parameters, like timeout, memory size or CPU power \cite{COSE}.

A serverless function can be triggered through events or HTTP requests following which the FaaS provider executes it in a containerized environment, like container, virtual machine or even processes, using the specified configuration.

\subsection{Serverless Application}

A \textit{serverless application} represents a stateless and event-driven software system made up of a set of serverless functions hosted on one or more FaaS platforms and combined together by an \textit{orchestrator}, which handles events among functions and triggers them in the correct order according to the business logic defined by developers. 

\section{Orchestrator Model}

\subsection{Resource owner}

A \textit{resource owner}, henceforward denoted with $R$, represents an entity capable of \textit{creating}, \textit{modifying} and \textit{authorizing} access to several resources of our system.

A \textit{function choreography} is the most important resource of our system and it is used to model both server-less functions and server-less function compositions.

Informally, it represents, using graph notation, all paths that might be traversed through a server-less function composition during its execution. In other words, it describes calling relationships between server-less functions.

Formally, being $R$ the resource owner, a \textbf{function choreography}, denoted as $FC_R$, is a \textit{control-flow graph} $G(V,E)$, where:

\begin{itemize}
	\item Each node $v \in V$, called \textit{abstract control-flow node}, represents a generic function of a computer program.
	\item Each edge $(v_i, v_j) \in E$, for any $i,j \in \mathbb{N}$ with $i \neq j$, indicates that the generic function $v_i$ calls that in $v_j$.
\end{itemize} 

Any function choreography can be  uniquely identified by an ordered string pair $(a, b)$, where $a$ is the \textit{resource owner name} while $b$ is the \textit{function choreography name}.

There are two types of abstract control-flow nodes:

\begin{description}
	\item[Abstract server-less function] denoted as $f_{(abstract, i)}$ while the set of all server-less functions is denoted as $F_{abstract}$.
	\item[Control-flow function] denoted ad $c_t$ while $C$ is the corresponding set of all control-flow functions.
\end{description}

Formally, let $|V| = n$, $|F_{abstract}| = t$, and $|C| = k$, where $t,k \in \mathbb{N}$ with $t + k = n$, we have that:

\begin{equation}
	\begin{array}{lll}
		
		V & \mathDef & F_{abstract} \cup C \\
		& = & (f_{(abstract, 1)}, \ldots, f_{(abstract, t)}) \cup (c_1, \ldots, c_k) \\
	\end{array}
\end{equation}

Clearly, we said that function choreography models a server-less function, when $|V| = 1$ and $|E| = 0$; conversely, it models a server-less function composition, when $|V| > 1$ and $|E| > 0$.

\subsubsection{Abstract server-less function}

An \textit{abstract server-less function} represents a descriptions of one or more corresponding concrete server-less function implementations. That description includes:

\begin{itemize}
	
	\item TODO
	\item TODO
	\item TODO
	
\end{itemize}

Any abstract server-less function can be uniquely identified by an ordered string pair $(a, b)$, where $a$ is the \textit{resource owner name} while $b$ is the \textit{abstract server-less function name}.

\subsubsection{Concrete server-less function}

Given an abstract server-less function, a resource owner can provide different implementations which, although they must be semantically equivalent, may eventually expose different performance or cost behaviour.

Therefore, we call \textit{concrete server-less function} any implementation of a given abstract function and it is uniquely identified by an ordered string tuple $(a, b, c)$, where $a$ and $b$ represent, like before, the \textit{resource owner name} and the \textit{abstract function name} respectively, while $c$ represents the so-called \textit{function type}, which is an abstract descriptions of the corresponding function implementation.

\subsubsection{Control-flow operator}

Like \texttt{if}, \texttt{for}, etc.


\section{Performance Modeling}

\subsection{Definition of serverless workflow}

Let $n \in \N \setminus \left\lbrace 0 \right\rbrace $, a serverless workflow $G_s$ is defined as a weighted directed graph:

\begin{equation}
G_s \mathDef \left( V, E, P, D, RT, RT T P, M, NI, C \right)  
\end{equation}

where

\begin{itemize}
	\item $V$ represents a finite set of $|V| = n$ vertices such that $V = \left\lbrace \mathscr{F}_1, \mathscr{F}_2, ..., \mathscr{F}_{n-1}, \mathscr{F}_n \right\rbrace $, where, for all $i \in \left[ 1, n \right] $, each $\mathscr{F}_i$ represents an abstract FaaS function;
	
	\item $E \subseteq V \times V $ represents a finite set of directed edges where, for all $v,u \in \left[ 1, n \right]$, each directed edge from $\mathscr{F}_u \in V \in V$ to $\mathscr{F}_v \in V$, denoted as $\left( \mathscr{F}_u, \mathscr{F}_v \right)$, represents the interaction between $\mathscr{F}_u$ and $\mathscr{F}_v$ defined by the business logic;
	
	\item $P : V \times V \to \left[  0, 1 \right]$ is a the transition probability function where $P\left(\mathscr{F}_u, \mathscr{F}_v \right) $ represents the probability of invoking
	$\mathscr{F}_v$ after finishing the execution of $\mathscr{F}_u$. 
	
	Clearly, when $P\left(\mathscr{F}_u, \mathscr{F}_v \right) = 0$, it means that the $\left( \mathscr{F}_u, \mathscr{F}_v \right)$ does not exist.
	
\end{itemize}

\newpage
\section{Aim}

Let $G_s$ a serverless workflow, the basic goal of our framework is to determine a so-called \textit{serverless workflow configuration} $\pi$ that allows us to meet user-specified QoS objectives.

Precisely, $\textbf{x}$ is a vector such that

\begin{equation}
\textbf{x} \in \lbrace \textbf{F}_1 \times \mathbb{N} \rbrace \times \ldots \times \lbrace \textbf{F}_n \times \mathbb{N} \rbrace = \Cross_{i = 1}^n \lbrace \textbf{F}_i \times \mathbb{N} \rbrace
\end{equation}

In other words, for all $1 \leq i \leq n$, $\textbf{x}$ is a vector containing $n$ ordered pairs $\left( f_i, m_i \right) $ called \textit{configuration} of the abstract serverless function $\mathscr{F}_i$, where $f_i$ represents a concrete serverless function while $m_i$ denotes its  allocated memory size. In other words, the aim of our framework is to find the most suitable configuration in order to achieve user-specified QoS objectives. 

 A path in the serverless workflow is a finite sequence of distinct vertices and edges $w =
\mathscr{F}_1 e1 \mathscr{F}_2 e2 \ldots \mathscr{F}_{n-1} \mathscr{F}_n$ such that:

The transition probability of the simple path $w$

Before to proceed, when the serverless workflow configuration $x$ is used,




\begin{itemize}
	\item $D(\textbf{x})$ denotes the end-to-end response time of current serverless workflow $G_s$ when the serverless workflow configuration $x$ is used. At the same time, $C(\textbf{x})$ represents the  
	\item $C(\textbf{x})$ re
\end{itemize}

gdfgdfgdfgd

\begin{itemize}
	\item $\textbf{x}(\mathscr{F})$ is used to denote the configuration $\left( f, m \right) $ of the serverless abstract function $\mathscr{F}$.
	\item $C_{func}(\textbf{x}(\mathscr{F}))$ represents the cost to pay to execute the concrete serverless function $f$ with memory size $m$.
\end{itemize}

\begin{equation}
	TPP(w) = \prod_{i = 1}^{n-1} P\left(\mathscr{F}_i, \mathscr{F}_{i+1} \right)
\end{equation}

\begin{equation}
	C_{walk}(w, \textbf{x}) = \sum_{\mathscr{F} \in w} C_{func}(\textbf{x}(\mathscr{F}))
\end{equation}


\begin{equation}
	C_{conf}(\textbf{x}) = \sum_{w \in SP_{G_s}(\mathscr{F}_{start}, \mathscr{F}_{end})} TPP(w) C(w, \textbf{x})
\end{equation}


\begin{equation}
\begin{array} {lllrrr} 
\displaystyle \operatorname*{arg\,min}_\pi & \displaystyle\sum_{i = 1}^n C_{\pi}(x_{ij})x_{ij} \\\\
& \displaystyle\sum_{n = 1}^N \sum_{k = 1}^K \sum_{x \in C} T(x)^{f_k^i} Y_x^{f_k^i} & \leq &  D_{\textbf{F}} \\
& \displaystyle\sum_{j = 1}^{n_i} x_{ij} & = & 1 & \forall i \in \lbrace 0, n \rbrace \\\\
& x_{ij} \in \lbrace 0, 1 \rbrace &&
\end{array}
\end{equation}
















